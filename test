import {
    FunctionDefinition, OnHeartbeat, OnInit, ServerFramework as Framework, Service
} from 'shared/framework';

import t from '@rbxts/t';

import { ColorService } from './color.service';
import { TestService } from './test.service';
import { TimeService } from './time.service';

class TestHelloService extends Service {
    sayHello(): void {
        print('hello');
    }
}

class TestGoodbyeService extends Service {
    sayGoodbye(): void {
        print('goodbye');
    }
}

class TestLifeService extends Service implements OnInit {
    public testHelloService?: TestHelloService = undefined;
    public testGoodbyeService?: TestGoodbyeService = undefined;

    public onInit(): void {
        this.testHelloService = Framework.getService(TestHelloService);
        this.testGoodbyeService = Framework.getService(TestGoodbyeService);
    }

    live(): void {
        this.testHelloService!.sayHello();
        this.testGoodbyeService!.sayGoodbye();
    }
}

class TestHeartbeatService extends Service implements OnHeartbeat {
    onHeartbeat(step: number) {
        // print('beat', step);
    }
}

Framework.setup();

Framework.registerServices([
    TestHelloService,
    TestGoodbyeService,
    TestLifeService,
    TestHeartbeatService,
    ColorService,
    TimeService,
    TestService
]);

let counter = 0;

export class TestFunction extends FunctionDefinition {
    func(player: Player, test: string): string {
        print(`${player.Name} said ${test} (${++counter})`);
        return 'test from server';
    }

    typeChecks(): t.check<unknown>[] {
        return [t.string];
    }
}

Framework.registerRemoteFunction(TestFunction);

// export type StringCheckFunction = (test: string) => boolean;

// Framework.registerRemoteFunction<StringCheckFunction>(
//     'StringCheckFunction',
//     (player: Player, test: string) => {
//         return true;
//     },
//     [t.string]
// );

Framework.start();

Framework.getService(TestLifeService).live();

export default {};



import t from '@rbxts/t';

export interface OnInit {
    onInit(): void;
}

export interface OnHeartbeat {
    onHeartbeat(step: number): void;
}

export abstract class Service {}

export abstract class FunctionDefinition {
    abstract func(...any: any[]): any;

    abstract typeChecks(): t.check<unknown>[];
}

type FunctionDefinitionConstructor = new () => FunctionDefinition;

export type ClientFunction<T> = T extends (...args: infer U) => infer R ? (player: Player, ...args: U) => R : never;

type ServiceConstructor = new (...services: Service[]) => Service;

const FRAMEWORK_FOLDER_NAME = 'Framework';

export class ServerFramework {
    private static frameworkFolder: Folder;
    private static functionFolder: Folder;
    private static services = new Map<string, Service>();

    private constructor() {}

    public static setup(): void {
        this.frameworkFolder = new Instance('Folder');
        this.frameworkFolder.Name = FRAMEWORK_FOLDER_NAME;
        this.functionFolder = new Instance('Folder', this.frameworkFolder);
        this.functionFolder.Name = 'Functions';
    }

    public static registerServices(serviceConstructors: ServiceConstructor[]): void {
        serviceConstructors.forEach((serviceConstructor) => this.registerService(serviceConstructor));
    }

    public static registerService(serviceConstructor: ServiceConstructor): void {
        const serviceKey = tostring(serviceConstructor);
        if (this.services.has(serviceKey)) throw `Duplicate service for name ${serviceKey}!`;
        this.services.set(tostring(serviceConstructor), new serviceConstructor());
    }

    public static getService<S extends ServiceConstructor>(serviceConstructor: S): InstanceType<S> {
        const serviceKey = tostring(serviceConstructor);
        if (!this.services.has(serviceKey)) throw `No service registered for name ${serviceKey}!`;
        return this.services.get(serviceKey) as InstanceType<S>;
    }

    public static registerRemoteFunction<T extends FunctionDefinitionConstructor>(functionDefinition: T): void {
        const remoteFunction = new Instance('RemoteFunction');
        const name = tostring(functionDefinition);
        remoteFunction.Name = name;
        remoteFunction.Parent = this.functionFolder;
        const func = new functionDefinition();
        remoteFunction.OnServerInvoke = (player: Player, ...args: unknown[]) => {
            if (args.size() !== func.typeChecks().size()) throw `Wrong number of arguments for function ${name}`;
            func.typeChecks().forEach((tCheck, i) => {
                if (!tCheck(args[i])) throw `Invalid argument for function ${name} at index ${i}`;
            });
            return func.func(player, ...args);
        };
    }

    public static start(): void {
        this.services.values().forEach((service) => {
            if ('onInit' in service) {
                (service as OnInit).onInit();
            }
            if ('onHeartbeat' in service) {
                game.GetService('RunService').Heartbeat.Connect((step) => (service as OnHeartbeat).onHeartbeat(step));
            }
        });

        this.frameworkFolder.Parent = script.Parent;
    }
}

export class ClientFramework {
    private static frameworkFolder: Folder;
    private static functionFolder: Folder;
    private constructor() {}

    public static async started(): Promise<void> {
        this.frameworkFolder = script.Parent?.WaitForChild(FRAMEWORK_FOLDER_NAME) as Folder;
        this.functionFolder = this.frameworkFolder.WaitForChild('Functions') as Folder;
    }

    public static getRemoteFunction<T extends Function>(name: string): T {
        const remoteFunction = this.functionFolder.FindFirstChild(name);
        if (remoteFunction === undefined) throw `Could not find function ${name}!`;

        return (((...args: unknown[]) => (remoteFunction as RemoteFunction).InvokeServer(...args)) as unknown) as T;
    }
}
